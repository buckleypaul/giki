package git

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/plumbing"
)

// TestNewLocalProvider_GikiRepoItself tests opening the giki repository itself.
func TestNewLocalProvider_GikiRepoItself(t *testing.T) {
	// Get the root of the giki repository (two levels up from internal/git)
	cwd, err := os.Getwd()
	if err != nil {
		t.Fatalf("failed to get working directory: %v", err)
	}
	repoRoot := filepath.Join(cwd, "..", "..")

	provider, err := NewLocalProvider(repoRoot, "")
	if err != nil {
		t.Fatalf("expected to open giki repo, got error: %v", err)
	}

	if provider == nil {
		t.Fatal("expected non-nil provider")
	}

	if provider.repo == nil {
		t.Fatal("expected non-nil repo")
	}

	if provider.path != repoRoot {
		t.Errorf("expected path %q, got %q", repoRoot, provider.path)
	}

	// Should have resolved to a branch name (typically "main")
	if provider.branch == "" {
		t.Error("expected branch to be resolved, got empty string")
	}
}

// TestNewLocalProvider_NonGitDirectory tests that non-git directories return expected error.
func TestNewLocalProvider_NonGitDirectory(t *testing.T) {
	tempDir := t.TempDir()

	_, err := NewLocalProvider(tempDir, "")
	if err == nil {
		t.Fatal("expected error for non-git directory, got nil")
	}

	expectedMsg := "is not a git repository"
	if !strings.Contains(err.Error(), expectedMsg) {
		t.Errorf("expected error to contain %q, got: %v", expectedMsg, err)
	}

	// Verify the path is included in the error message
	if !strings.Contains(err.Error(), tempDir) {
		t.Errorf("expected error to contain path %q, got: %v", tempDir, err)
	}
}

// TestNewLocalProvider_NonexistentBranch tests that nonexistent branches return expected error.
func TestNewLocalProvider_NonexistentBranch(t *testing.T) {
	// Create a temporary git repository
	tempDir := t.TempDir()
	repo, err := git.PlainInit(tempDir, false)
	if err != nil {
		t.Fatalf("failed to init test repo: %v", err)
	}

	// Create an initial commit so HEAD points to a valid branch
	w, err := repo.Worktree()
	if err != nil {
		t.Fatalf("failed to get worktree: %v", err)
	}

	testFile := filepath.Join(tempDir, "test.txt")
	if err := os.WriteFile(testFile, []byte("test"), 0644); err != nil {
		t.Fatalf("failed to write test file: %v", err)
	}

	if _, err := w.Add("test.txt"); err != nil {
		t.Fatalf("failed to add file: %v", err)
	}

	if _, err := w.Commit("initial commit", &git.CommitOptions{}); err != nil {
		t.Fatalf("failed to commit: %v", err)
	}

	// Try to open with nonexistent branch
	_, err = NewLocalProvider(tempDir, "nonexistent")
	if err == nil {
		t.Fatal("expected error for nonexistent branch, got nil")
	}

	expectedMsg := "branch 'nonexistent' not found"
	if err.Error() != expectedMsg {
		t.Errorf("expected error %q, got: %v", expectedMsg, err)
	}
}

// TestNewLocalProvider_HEADBranchResolves tests that HEAD branch resolves correctly.
func TestNewLocalProvider_HEADBranchResolves(t *testing.T) {
	// Create a temporary git repository
	tempDir := t.TempDir()
	repo, err := git.PlainInit(tempDir, false)
	if err != nil {
		t.Fatalf("failed to init test repo: %v", err)
	}

	// Create an initial commit so HEAD points to a valid branch
	w, err := repo.Worktree()
	if err != nil {
		t.Fatalf("failed to get worktree: %v", err)
	}

	testFile := filepath.Join(tempDir, "test.txt")
	if err := os.WriteFile(testFile, []byte("test"), 0644); err != nil {
		t.Fatalf("failed to write test file: %v", err)
	}

	if _, err := w.Add("test.txt"); err != nil {
		t.Fatalf("failed to add file: %v", err)
	}

	if _, err := w.Commit("initial commit", &git.CommitOptions{}); err != nil {
		t.Fatalf("failed to commit: %v", err)
	}

	// Open without specifying branch (should resolve to current branch)
	provider, err := NewLocalProvider(tempDir, "")
	if err != nil {
		t.Fatalf("expected to open repo, got error: %v", err)
	}

	// Default branch for git init is "master" or "main" depending on git config
	// Just verify it's not empty
	if provider.branch == "" {
		t.Error("expected branch to be resolved, got empty string")
	}
}

// TestNewLocalProvider_ExplicitBranch tests opening with an explicit valid branch.
func TestNewLocalProvider_ExplicitBranch(t *testing.T) {
	// Create a temporary git repository with multiple branches
	tempDir := t.TempDir()
	repo, err := git.PlainInit(tempDir, false)
	if err != nil {
		t.Fatalf("failed to init test repo: %v", err)
	}

	// Create initial commit on main branch
	w, err := repo.Worktree()
	if err != nil {
		t.Fatalf("failed to get worktree: %v", err)
	}

	testFile := filepath.Join(tempDir, "test.txt")
	if err := os.WriteFile(testFile, []byte("test"), 0644); err != nil {
		t.Fatalf("failed to write test file: %v", err)
	}

	if _, err := w.Add("test.txt"); err != nil {
		t.Fatalf("failed to add file: %v", err)
	}

	commit, err := w.Commit("initial commit", &git.CommitOptions{})
	if err != nil {
		t.Fatalf("failed to commit: %v", err)
	}

	// Create a new branch "dev"
	headRef, err := repo.Head()
	if err != nil {
		t.Fatalf("failed to get HEAD: %v", err)
	}
	devBranch := plumbing.NewBranchReferenceName("dev")
	devRef := plumbing.NewHashReference(devBranch, commit)
	if err := repo.Storer.SetReference(devRef); err != nil {
		t.Fatalf("failed to create dev branch: %v", err)
	}

	// Open with explicit branch "dev"
	provider, err := NewLocalProvider(tempDir, "dev")
	if err != nil {
		t.Fatalf("expected to open repo with dev branch, got error: %v", err)
	}

	if provider.branch != "dev" {
		t.Errorf("expected branch 'dev', got %q", provider.branch)
	}

	// Verify HEAD branch still works
	currentBranch := headRef.Name().Short()
	provider2, err := NewLocalProvider(tempDir, currentBranch)
	if err != nil {
		t.Fatalf("expected to open repo with current branch, got error: %v", err)
	}

	if provider2.branch != currentBranch {
		t.Errorf("expected branch %q, got %q", currentBranch, provider2.branch)
	}
}

// TestTree_KnownStructure tests that Tree returns the expected structure for a known repo.
func TestTree_KnownStructure(t *testing.T) {
	// Create a temporary git repository with a known structure
	tempDir := t.TempDir()
	repo, err := git.PlainInit(tempDir, false)
	if err != nil {
		t.Fatalf("failed to init test repo: %v", err)
	}

	w, err := repo.Worktree()
	if err != nil {
		t.Fatalf("failed to get worktree: %v", err)
	}

	// Create files and directories:
	// - README.md (root)
	// - docs/
	//   - setup.md
	// - src/
	//   - main.go
	//   - utils/
	//     - helper.go
	files := map[string]string{
		"README.md":         "# Test",
		"docs/setup.md":     "# Setup",
		"src/main.go":       "package main",
		"src/utils/helper.go": "package utils",
	}

	for path, content := range files {
		fullPath := filepath.Join(tempDir, path)
		if err := os.MkdirAll(filepath.Dir(fullPath), 0755); err != nil {
			t.Fatalf("failed to create directory: %v", err)
		}
		if err := os.WriteFile(fullPath, []byte(content), 0644); err != nil {
			t.Fatalf("failed to write file %s: %v", path, err)
		}
		if _, err := w.Add(path); err != nil {
			t.Fatalf("failed to add file %s: %v", path, err)
		}
	}

	if _, err := w.Commit("initial commit", &git.CommitOptions{}); err != nil {
		t.Fatalf("failed to commit: %v", err)
	}

	// Create provider and get tree
	provider, err := NewLocalProvider(tempDir, "")
	if err != nil {
		t.Fatalf("failed to create provider: %v", err)
	}

	tree, err := provider.Tree("")
	if err != nil {
		t.Fatalf("Tree() failed: %v", err)
	}

	// Verify root has 3 children: docs (dir), src (dir), README.md (file)
	if len(tree.Children) != 3 {
		t.Errorf("expected 3 root children, got %d", len(tree.Children))
	}

	// Verify sort order: directories first (docs, src), then files (README.md)
	if len(tree.Children) >= 3 {
		if !tree.Children[0].IsDir || tree.Children[0].Name != "docs" {
			t.Errorf("expected first child to be 'docs' directory, got: %+v", tree.Children[0])
		}
		if !tree.Children[1].IsDir || tree.Children[1].Name != "src" {
			t.Errorf("expected second child to be 'src' directory, got: %+v", tree.Children[1])
		}
		if tree.Children[2].IsDir || tree.Children[2].Name != "README.md" {
			t.Errorf("expected third child to be 'README.md' file, got: %+v", tree.Children[2])
		}

		// Verify docs has 1 child: setup.md
		if len(tree.Children[0].Children) != 1 {
			t.Errorf("expected docs to have 1 child, got %d", len(tree.Children[0].Children))
		} else {
			if tree.Children[0].Children[0].Name != "setup.md" {
				t.Errorf("expected docs child to be 'setup.md', got %s", tree.Children[0].Children[0].Name)
			}
		}

		// Verify src has 2 children: utils (dir), main.go (file)
		if len(tree.Children[1].Children) != 2 {
			t.Errorf("expected src to have 2 children, got %d", len(tree.Children[1].Children))
		} else {
			if !tree.Children[1].Children[0].IsDir || tree.Children[1].Children[0].Name != "utils" {
				t.Errorf("expected src first child to be 'utils' directory, got: %+v", tree.Children[1].Children[0])
			}
			if tree.Children[1].Children[1].IsDir || tree.Children[1].Children[1].Name != "main.go" {
				t.Errorf("expected src second child to be 'main.go' file, got: %+v", tree.Children[1].Children[1])
			}
		}
	}
}

// TestTree_GitignoreExcluded tests that .gitignore'd files are excluded from tree.
func TestTree_GitignoreExcluded(t *testing.T) {
	tempDir := t.TempDir()
	repo, err := git.PlainInit(tempDir, false)
	if err != nil {
		t.Fatalf("failed to init test repo: %v", err)
	}

	w, err := repo.Worktree()
	if err != nil {
		t.Fatalf("failed to get worktree: %v", err)
	}

	// Create .gitignore
	gitignoreContent := `# Ignore node_modules
node_modules/
*.log
build/
`
	if err := os.WriteFile(filepath.Join(tempDir, ".gitignore"), []byte(gitignoreContent), 0644); err != nil {
		t.Fatalf("failed to write .gitignore: %v", err)
	}

	// Create files: some tracked, some ignored
	files := map[string]string{
		".gitignore":            gitignoreContent,
		"README.md":             "# Test",
		"src/main.go":           "package main",
		"node_modules/pkg.json": `{"name": "test"}`, // Should be ignored
		"debug.log":             "log content",      // Should be ignored
		"build/output.js":       "var x = 1;",       // Should be ignored
	}

	for path, content := range files {
		fullPath := filepath.Join(tempDir, path)
		if err := os.MkdirAll(filepath.Dir(fullPath), 0755); err != nil {
			t.Fatalf("failed to create directory: %v", err)
		}
		if err := os.WriteFile(fullPath, []byte(content), 0644); err != nil {
			t.Fatalf("failed to write file %s: %v", path, err)
		}
	}

	// Only add non-ignored files to git
	for _, path := range []string{".gitignore", "README.md", "src/main.go"} {
		if _, err := w.Add(path); err != nil {
			t.Fatalf("failed to add file %s: %v", path, err)
		}
	}

	if _, err := w.Commit("initial commit", &git.CommitOptions{}); err != nil {
		t.Fatalf("failed to commit: %v", err)
	}

	// Create provider and get tree
	provider, err := NewLocalProvider(tempDir, "")
	if err != nil {
		t.Fatalf("failed to create provider: %v", err)
	}

	tree, err := provider.Tree("")
	if err != nil {
		t.Fatalf("Tree() failed: %v", err)
	}

	// Helper function to find a node by path
	hasPath := func(node *TreeNode, targetPath string) bool {
		var search func(*TreeNode, string) bool
		search = func(n *TreeNode, path string) bool {
			if n.Path == path {
				return true
			}
			for i := range n.Children {
				if search(&n.Children[i], path) {
					return true
				}
			}
			return false
		}
		return search(node, targetPath)
	}

	// Verify tracked files are present
	if !hasPath(tree, ".gitignore") {
		t.Error(".gitignore should be in tree")
	}
	if !hasPath(tree, "README.md") {
		t.Error("README.md should be in tree")
	}
	if !hasPath(tree, "src/main.go") {
		t.Error("src/main.go should be in tree")
	}

	// Verify ignored files are NOT present
	if hasPath(tree, "node_modules/pkg.json") {
		t.Error("node_modules/pkg.json should be ignored")
	}
	if hasPath(tree, "debug.log") {
		t.Error("debug.log should be ignored")
	}
	if hasPath(tree, "build/output.js") {
		t.Error("build/output.js should be ignored")
	}
}

// TestTree_TrackedDotfilesIncluded tests that tracked dotfiles are included.
func TestTree_TrackedDotfilesIncluded(t *testing.T) {
	tempDir := t.TempDir()
	repo, err := git.PlainInit(tempDir, false)
	if err != nil {
		t.Fatalf("failed to init test repo: %v", err)
	}

	w, err := repo.Worktree()
	if err != nil {
		t.Fatalf("failed to get worktree: %v", err)
	}

	// Create dotfiles and directory
	files := []string{
		".gitignore",
		".github/workflows/ci.yml",
		"README.md",
	}

	for _, path := range files {
		fullPath := filepath.Join(tempDir, path)
		if err := os.MkdirAll(filepath.Dir(fullPath), 0755); err != nil {
			t.Fatalf("failed to create directory: %v", err)
		}
		if err := os.WriteFile(fullPath, []byte("content"), 0644); err != nil {
			t.Fatalf("failed to write file %s: %v", path, err)
		}
		if _, err := w.Add(path); err != nil {
			t.Fatalf("failed to add file %s: %v", path, err)
		}
	}

	if _, err := w.Commit("initial commit", &git.CommitOptions{}); err != nil {
		t.Fatalf("failed to commit: %v", err)
	}

	provider, err := NewLocalProvider(tempDir, "")
	if err != nil {
		t.Fatalf("failed to create provider: %v", err)
	}

	tree, err := provider.Tree("")
	if err != nil {
		t.Fatalf("Tree() failed: %v", err)
	}

	// Helper function to find a node by path
	hasPath := func(node *TreeNode, targetPath string) bool {
		var search func(*TreeNode, string) bool
		search = func(n *TreeNode, path string) bool {
			if n.Path == path {
				return true
			}
			for i := range n.Children {
				if search(&n.Children[i], path) {
					return true
				}
			}
			return false
		}
		return search(node, targetPath)
	}

	if !hasPath(tree, ".gitignore") {
		t.Error(".gitignore should be in tree")
	}
	if !hasPath(tree, ".github/workflows/ci.yml") {
		t.Error(".github/workflows/ci.yml should be in tree")
	}
}

// TestTree_SortOrderCorrect tests that sort order is correct (directories first, alphabetical).
func TestTree_SortOrderCorrect(t *testing.T) {
	tempDir := t.TempDir()
	repo, err := git.PlainInit(tempDir, false)
	if err != nil {
		t.Fatalf("failed to init test repo: %v", err)
	}

	w, err := repo.Worktree()
	if err != nil {
		t.Fatalf("failed to get worktree: %v", err)
	}

	// Create files with names that test alphabetical sorting
	files := []string{
		"zebra.md",
		"apple.md",
		"Beta.md", // capital B - should still sort alphabetically (case-insensitive)
		"zoo/",
		"ant/",
	}

	for _, path := range files {
		fullPath := filepath.Join(tempDir, path)
		if strings.HasSuffix(path, "/") {
			// Directory - create a file inside it
			if err := os.MkdirAll(fullPath, 0755); err != nil {
				t.Fatalf("failed to create directory: %v", err)
			}
			filePath := filepath.Join(fullPath, "file.txt")
			if err := os.WriteFile(filePath, []byte("content"), 0644); err != nil {
				t.Fatalf("failed to write file: %v", err)
			}
			if _, err := w.Add(strings.TrimSuffix(path, "/") + "/file.txt"); err != nil {
				t.Fatalf("failed to add file: %v", err)
			}
		} else {
			if err := os.WriteFile(fullPath, []byte("content"), 0644); err != nil {
				t.Fatalf("failed to write file: %v", err)
			}
			if _, err := w.Add(path); err != nil {
				t.Fatalf("failed to add file: %v", err)
			}
		}
	}

	if _, err := w.Commit("initial commit", &git.CommitOptions{}); err != nil {
		t.Fatalf("failed to commit: %v", err)
	}

	provider, err := NewLocalProvider(tempDir, "")
	if err != nil {
		t.Fatalf("failed to create provider: %v", err)
	}

	tree, err := provider.Tree("")
	if err != nil {
		t.Fatalf("Tree() failed: %v", err)
	}

	// Expected order: ant (dir), zoo (dir), apple.md, Beta.md, zebra.md
	expected := []struct {
		name  string
		isDir bool
	}{
		{"ant", true},
		{"zoo", true},
		{"apple.md", false},
		{"Beta.md", false},
		{"zebra.md", false},
	}

	if len(tree.Children) != len(expected) {
		t.Fatalf("expected %d children, got %d", len(expected), len(tree.Children))
	}

	for i, exp := range expected {
		if tree.Children[i].Name != exp.name {
			t.Errorf("child %d: expected name %q, got %q", i, exp.name, tree.Children[i].Name)
		}
		if tree.Children[i].IsDir != exp.isDir {
			t.Errorf("child %d (%s): expected IsDir=%v, got %v", i, exp.name, exp.isDir, tree.Children[i].IsDir)
		}
	}
}

// TestFileContent_ReadKnownFile tests reading a known file returns correct contents.
func TestFileContent_ReadKnownFile(t *testing.T) {
	tempDir := t.TempDir()
	repo, err := git.PlainInit(tempDir, false)
	if err != nil {
		t.Fatalf("failed to init test repo: %v", err)
	}

	w, err := repo.Worktree()
	if err != nil {
		t.Fatalf("failed to get worktree: %v", err)
	}

	// Create test files
	testContent := "# Test README\n\nThis is a test file."
	readmePath := filepath.Join(tempDir, "README.md")
	if err := os.WriteFile(readmePath, []byte(testContent), 0644); err != nil {
		t.Fatalf("failed to write test file: %v", err)
	}

	if _, err := w.Add("README.md"); err != nil {
		t.Fatalf("failed to add file: %v", err)
	}

	if _, err := w.Commit("initial commit", &git.CommitOptions{}); err != nil {
		t.Fatalf("failed to commit: %v", err)
	}

	// Create provider
	provider, err := NewLocalProvider(tempDir, "")
	if err != nil {
		t.Fatalf("failed to create provider: %v", err)
	}

	// Read file content
	content, err := provider.FileContent("README.md", "")
	if err != nil {
		t.Fatalf("FileContent() failed: %v", err)
	}

	if string(content) != testContent {
		t.Errorf("expected content %q, got %q", testContent, string(content))
	}
}

// TestFileContent_NonexistentFile tests that nonexistent files return proper error.
func TestFileContent_NonexistentFile(t *testing.T) {
	tempDir := t.TempDir()
	repo, err := git.PlainInit(tempDir, false)
	if err != nil {
		t.Fatalf("failed to init test repo: %v", err)
	}

	w, err := repo.Worktree()
	if err != nil {
		t.Fatalf("failed to get worktree: %v", err)
	}

	// Create initial commit
	readmePath := filepath.Join(tempDir, "README.md")
	if err := os.WriteFile(readmePath, []byte("test"), 0644); err != nil {
		t.Fatalf("failed to write test file: %v", err)
	}

	if _, err := w.Add("README.md"); err != nil {
		t.Fatalf("failed to add file: %v", err)
	}

	if _, err := w.Commit("initial commit", &git.CommitOptions{}); err != nil {
		t.Fatalf("failed to commit: %v", err)
	}

	provider, err := NewLocalProvider(tempDir, "")
	if err != nil {
		t.Fatalf("failed to create provider: %v", err)
	}

	// Try to read nonexistent file
	_, err = provider.FileContent("nonexistent.md", "")
	if err == nil {
		t.Fatal("expected error for nonexistent file, got nil")
	}

	if !strings.Contains(err.Error(), "file not found") {
		t.Errorf("expected error to contain 'file not found', got: %v", err)
	}
}

// TestFileContent_Directory tests that reading a directory returns proper error.
func TestFileContent_Directory(t *testing.T) {
	tempDir := t.TempDir()
	repo, err := git.PlainInit(tempDir, false)
	if err != nil {
		t.Fatalf("failed to init test repo: %v", err)
	}

	w, err := repo.Worktree()
	if err != nil {
		t.Fatalf("failed to get worktree: %v", err)
	}

	// Create directory with a file inside
	docsDir := filepath.Join(tempDir, "docs")
	if err := os.MkdirAll(docsDir, 0755); err != nil {
		t.Fatalf("failed to create directory: %v", err)
	}

	filePath := filepath.Join(docsDir, "test.md")
	if err := os.WriteFile(filePath, []byte("test"), 0644); err != nil {
		t.Fatalf("failed to write test file: %v", err)
	}

	if _, err := w.Add("docs/test.md"); err != nil {
		t.Fatalf("failed to add file: %v", err)
	}

	if _, err := w.Commit("initial commit", &git.CommitOptions{}); err != nil {
		t.Fatalf("failed to commit: %v", err)
	}

	provider, err := NewLocalProvider(tempDir, "")
	if err != nil {
		t.Fatalf("failed to create provider: %v", err)
	}

	// Try to read directory as if it were a file
	_, err = provider.FileContent("docs", "")
	if err == nil {
		t.Fatal("expected error for directory, got nil")
	}

	if !strings.Contains(err.Error(), "directory") {
		t.Errorf("expected error to mention 'directory', got: %v", err)
	}
}

// TestFileContent_PathTraversalBlocked tests that path traversal attempts are blocked.
func TestFileContent_PathTraversalBlocked(t *testing.T) {
	tempDir := t.TempDir()
	repo, err := git.PlainInit(tempDir, false)
	if err != nil {
		t.Fatalf("failed to init test repo: %v", err)
	}

	w, err := repo.Worktree()
	if err != nil {
		t.Fatalf("failed to get worktree: %v", err)
	}

	// Create initial commit
	readmePath := filepath.Join(tempDir, "README.md")
	if err := os.WriteFile(readmePath, []byte("test"), 0644); err != nil {
		t.Fatalf("failed to write test file: %v", err)
	}

	if _, err := w.Add("README.md"); err != nil {
		t.Fatalf("failed to add file: %v", err)
	}

	if _, err := w.Commit("initial commit", &git.CommitOptions{}); err != nil {
		t.Fatalf("failed to commit: %v", err)
	}

	provider, err := NewLocalProvider(tempDir, "")
	if err != nil {
		t.Fatalf("failed to create provider: %v", err)
	}

	// Try path traversal attacks
	attacks := []string{
		"../../../etc/passwd",
		"docs/../../etc/passwd",
		"..%2F..%2F..%2Fetc%2Fpasswd",
	}

	for _, attack := range attacks {
		_, err := provider.FileContent(attack, "")
		if err == nil {
			t.Errorf("path traversal attack %q should have been blocked", attack)
		}
		if !strings.Contains(err.Error(), "invalid path") && !strings.Contains(err.Error(), "file not found") {
			t.Errorf("expected security error for %q, got: %v", attack, err)
		}
	}
}

// TestFileContent_NestedFile tests reading a file in nested directories.
func TestFileContent_NestedFile(t *testing.T) {
	tempDir := t.TempDir()
	repo, err := git.PlainInit(tempDir, false)
	if err != nil {
		t.Fatalf("failed to init test repo: %v", err)
	}

	w, err := repo.Worktree()
	if err != nil {
		t.Fatalf("failed to get worktree: %v", err)
	}

	// Create nested file
	testContent := "package utils\n\nfunc Helper() {}"
	nestedPath := filepath.Join(tempDir, "src", "utils", "helper.go")
	if err := os.MkdirAll(filepath.Dir(nestedPath), 0755); err != nil {
		t.Fatalf("failed to create directory: %v", err)
	}
	if err := os.WriteFile(nestedPath, []byte(testContent), 0644); err != nil {
		t.Fatalf("failed to write test file: %v", err)
	}

	if _, err := w.Add("src/utils/helper.go"); err != nil {
		t.Fatalf("failed to add file: %v", err)
	}

	if _, err := w.Commit("initial commit", &git.CommitOptions{}); err != nil {
		t.Fatalf("failed to commit: %v", err)
	}

	provider, err := NewLocalProvider(tempDir, "")
	if err != nil {
		t.Fatalf("failed to create provider: %v", err)
	}

	// Read nested file with forward slashes (git convention)
	content, err := provider.FileContent("src/utils/helper.go", "")
	if err != nil {
		t.Fatalf("FileContent() failed: %v", err)
	}

	if string(content) != testContent {
		t.Errorf("expected content %q, got %q", testContent, string(content))
	}
}

// TestBranches_MultipleBranches tests that all branches are returned with default flagged.
func TestBranches_MultipleBranches(t *testing.T) {
	tempDir := t.TempDir()
	repo, err := git.PlainInit(tempDir, false)
	if err != nil {
		t.Fatalf("failed to init test repo: %v", err)
	}

	w, err := repo.Worktree()
	if err != nil {
		t.Fatalf("failed to get worktree: %v", err)
	}

	// Create initial commit
	testFile := filepath.Join(tempDir, "test.txt")
	if err := os.WriteFile(testFile, []byte("test"), 0644); err != nil {
		t.Fatalf("failed to write test file: %v", err)
	}

	if _, err := w.Add("test.txt"); err != nil {
		t.Fatalf("failed to add file: %v", err)
	}

	commit, err := w.Commit("initial commit", &git.CommitOptions{})
	if err != nil {
		t.Fatalf("failed to commit: %v", err)
	}

	// Get the current branch name
	headRef, err := repo.Head()
	if err != nil {
		t.Fatalf("failed to get HEAD: %v", err)
	}
	currentBranch := headRef.Name().Short()

	// Create additional branches
	devRef := plumbing.NewHashReference(plumbing.NewBranchReferenceName("dev"), commit)
	if err := repo.Storer.SetReference(devRef); err != nil {
		t.Fatalf("failed to create dev branch: %v", err)
	}

	featureRef := plumbing.NewHashReference(plumbing.NewBranchReferenceName("feature"), commit)
	if err := repo.Storer.SetReference(featureRef); err != nil {
		t.Fatalf("failed to create feature branch: %v", err)
	}

	// Create provider (should use current branch as default)
	provider, err := NewLocalProvider(tempDir, "")
	if err != nil {
		t.Fatalf("failed to create provider: %v", err)
	}

	// Get branches
	branches, err := provider.Branches()
	if err != nil {
		t.Fatalf("Branches() failed: %v", err)
	}

	// Should have 3 branches
	if len(branches) != 3 {
		t.Fatalf("expected 3 branches, got %d", len(branches))
	}

	// Build a map for easier verification
	branchMap := make(map[string]BranchInfo)
	for _, b := range branches {
		branchMap[b.Name] = b
	}

	// Verify all branches exist
	if _, ok := branchMap[currentBranch]; !ok {
		t.Errorf("expected branch %q to be in list", currentBranch)
	}
	if _, ok := branchMap["dev"]; !ok {
		t.Error("expected branch 'dev' to be in list")
	}
	if _, ok := branchMap["feature"]; !ok {
		t.Error("expected branch 'feature' to be in list")
	}

	// Verify only current branch is marked as default
	defaultCount := 0
	for _, b := range branches {
		if b.IsDefault {
			defaultCount++
			if b.Name != currentBranch {
				t.Errorf("expected default branch to be %q, got %q", currentBranch, b.Name)
			}
		}
	}

	if defaultCount != 1 {
		t.Errorf("expected exactly 1 default branch, got %d", defaultCount)
	}
}

// TestBranches_SingleBranch tests that a repo with only one branch works correctly.
func TestBranches_SingleBranch(t *testing.T) {
	tempDir := t.TempDir()
	repo, err := git.PlainInit(tempDir, false)
	if err != nil {
		t.Fatalf("failed to init test repo: %v", err)
	}

	w, err := repo.Worktree()
	if err != nil {
		t.Fatalf("failed to get worktree: %v", err)
	}

	// Create initial commit
	testFile := filepath.Join(tempDir, "test.txt")
	if err := os.WriteFile(testFile, []byte("test"), 0644); err != nil {
		t.Fatalf("failed to write test file: %v", err)
	}

	if _, err := w.Add("test.txt"); err != nil {
		t.Fatalf("failed to add file: %v", err)
	}

	if _, err := w.Commit("initial commit", &git.CommitOptions{}); err != nil {
		t.Fatalf("failed to commit: %v", err)
	}

	// Create provider
	provider, err := NewLocalProvider(tempDir, "")
	if err != nil {
		t.Fatalf("failed to create provider: %v", err)
	}

	// Get branches
	branches, err := provider.Branches()
	if err != nil {
		t.Fatalf("Branches() failed: %v", err)
	}

	// Should have exactly 1 branch
	if len(branches) != 1 {
		t.Fatalf("expected 1 branch, got %d", len(branches))
	}

	// That branch should be marked as default
	if !branches[0].IsDefault {
		t.Error("expected single branch to be marked as default")
	}

	// Branch name should be non-empty
	if branches[0].Name == "" {
		t.Error("expected branch name to be non-empty")
	}
}

// TestStatus_CleanRepository tests that Status returns isDirty: false for a clean repository.
func TestStatus_CleanRepository(t *testing.T) {
	// Create a temp directory
	tempDir := t.TempDir()

	// Initialize a git repository
	repo, err := git.PlainInit(tempDir, false)
	if err != nil {
		t.Fatalf("failed to init repo: %v", err)
	}

	// Create and commit a file to have a clean state
	testFile := filepath.Join(tempDir, "README.md")
	if err := os.WriteFile(testFile, []byte("# Test"), 0644); err != nil {
		t.Fatalf("failed to write file: %v", err)
	}

	// Stage and commit the file
	worktree, err := repo.Worktree()
	if err != nil {
		t.Fatalf("failed to get worktree: %v", err)
	}

	if _, err := worktree.Add("README.md"); err != nil {
		t.Fatalf("failed to stage file: %v", err)
	}

	if _, err := worktree.Commit("Initial commit", &git.CommitOptions{}); err != nil {
		t.Fatalf("failed to commit: %v", err)
	}

	// Create provider
	provider, err := NewLocalProvider(tempDir, "")
	if err != nil {
		t.Fatalf("failed to create provider: %v", err)
	}

	// Get status
	status, err := provider.Status()
	if err != nil {
		t.Fatalf("failed to get status: %v", err)
	}

	// Verify status fields
	if status.Source != tempDir {
		t.Errorf("expected source %q, got %q", tempDir, status.Source)
	}

	if status.Branch != "master" {
		t.Errorf("expected branch 'master', got %q", status.Branch)
	}

	if status.IsDirty {
		t.Error("expected clean repository (isDirty: false), got isDirty: true")
	}
}

// TestStatus_DirtyRepository tests that Status returns isDirty: true for a repository with uncommitted changes.
func TestStatus_DirtyRepository(t *testing.T) {
	// Create a temp directory
	tempDir := t.TempDir()

	// Initialize a git repository
	repo, err := git.PlainInit(tempDir, false)
	if err != nil {
		t.Fatalf("failed to init repo: %v", err)
	}

	// Create and commit a file to establish baseline
	testFile := filepath.Join(tempDir, "README.md")
	if err := os.WriteFile(testFile, []byte("# Test"), 0644); err != nil {
		t.Fatalf("failed to write file: %v", err)
	}

	worktree, err := repo.Worktree()
	if err != nil {
		t.Fatalf("failed to get worktree: %v", err)
	}

	if _, err := worktree.Add("README.md"); err != nil {
		t.Fatalf("failed to stage file: %v", err)
	}

	if _, err := worktree.Commit("Initial commit", &git.CommitOptions{}); err != nil {
		t.Fatalf("failed to commit: %v", err)
	}

	// Now modify the file (create uncommitted changes)
	if err := os.WriteFile(testFile, []byte("# Test - Modified"), 0644); err != nil {
		t.Fatalf("failed to modify file: %v", err)
	}

	// Create provider
	provider, err := NewLocalProvider(tempDir, "")
	if err != nil {
		t.Fatalf("failed to create provider: %v", err)
	}

	// Get status
	status, err := provider.Status()
	if err != nil {
		t.Fatalf("failed to get status: %v", err)
	}

	// Verify isDirty is true
	if !status.IsDirty {
		t.Error("expected dirty repository (isDirty: true), got isDirty: false")
	}

	if status.Source != tempDir {
		t.Errorf("expected source %q, got %q", tempDir, status.Source)
	}

	if status.Branch != "master" {
		t.Errorf("expected branch 'master', got %q", status.Branch)
	}
}

// TestStatus_UntrackedFiles tests that Status returns isDirty: true when there are untracked files.
func TestStatus_UntrackedFiles(t *testing.T) {
	// Create a temp directory
	tempDir := t.TempDir()

	// Initialize a git repository
	repo, err := git.PlainInit(tempDir, false)
	if err != nil {
		t.Fatalf("failed to init repo: %v", err)
	}

	// Create and commit a file to establish baseline
	testFile := filepath.Join(tempDir, "README.md")
	if err := os.WriteFile(testFile, []byte("# Test"), 0644); err != nil {
		t.Fatalf("failed to write file: %v", err)
	}

	worktree, err := repo.Worktree()
	if err != nil {
		t.Fatalf("failed to get worktree: %v", err)
	}

	if _, err := worktree.Add("README.md"); err != nil {
		t.Fatalf("failed to stage file: %v", err)
	}

	if _, err := worktree.Commit("Initial commit", &git.CommitOptions{}); err != nil {
		t.Fatalf("failed to commit: %v", err)
	}

	// Add an untracked file
	untrackedFile := filepath.Join(tempDir, "untracked.txt")
	if err := os.WriteFile(untrackedFile, []byte("new file"), 0644); err != nil {
		t.Fatalf("failed to write untracked file: %v", err)
	}

	// Create provider
	provider, err := NewLocalProvider(tempDir, "")
	if err != nil {
		t.Fatalf("failed to create provider: %v", err)
	}

	// Get status
	status, err := provider.Status()
	if err != nil {
		t.Fatalf("failed to get status: %v", err)
	}

	// Verify isDirty is true (untracked files make the repo dirty)
	if !status.IsDirty {
		t.Error("expected dirty repository with untracked files (isDirty: true), got isDirty: false")
	}
}

// TestTree_NonHEADBranch tests that reading from a non-HEAD branch returns committed state.
func TestTree_NonHEADBranch(t *testing.T) {
	// Create a temporary git repository
	tempDir := t.TempDir()
	repo, err := git.PlainInit(tempDir, false)
	if err != nil {
		t.Fatalf("failed to init test repo: %v", err)
	}

	w, err := repo.Worktree()
	if err != nil {
		t.Fatalf("failed to get worktree: %v", err)
	}

	// Create initial file on main branch and commit
	mainFile := filepath.Join(tempDir, "main.txt")
	if err := os.WriteFile(mainFile, []byte("main content"), 0644); err != nil {
		t.Fatalf("failed to write main file: %v", err)
	}

	if _, err := w.Add("main.txt"); err != nil {
		t.Fatalf("failed to add file: %v", err)
	}

	if _, err := w.Commit("initial commit on main", &git.CommitOptions{}); err != nil {
		t.Fatalf("failed to commit: %v", err)
	}

	// Create a new branch "feature"
	headRef, err := repo.Head()
	if err != nil {
		t.Fatalf("failed to get HEAD: %v", err)
	}

	featureBranchRef := plumbing.NewBranchReferenceName("feature")
	err = repo.Storer.SetReference(plumbing.NewHashReference(featureBranchRef, headRef.Hash()))
	if err != nil {
		t.Fatalf("failed to create feature branch: %v", err)
	}

	// Checkout feature branch
	if err := w.Checkout(&git.CheckoutOptions{Branch: featureBranchRef}); err != nil {
		t.Fatalf("failed to checkout feature branch: %v", err)
	}

	// Create a file on feature branch and commit
	featureFile := filepath.Join(tempDir, "feature.txt")
	if err := os.WriteFile(featureFile, []byte("feature content"), 0644); err != nil {
		t.Fatalf("failed to write feature file: %v", err)
	}

	if _, err := w.Add("feature.txt"); err != nil {
		t.Fatalf("failed to add feature file: %v", err)
	}

	if _, err := w.Commit("add feature file", &git.CommitOptions{}); err != nil {
		t.Fatalf("failed to commit feature file: %v", err)
	}

	// Switch back to main branch
	mainBranchRef := plumbing.NewBranchReferenceName("master")
	if err := w.Checkout(&git.CheckoutOptions{Branch: mainBranchRef}); err != nil {
		t.Fatalf("failed to checkout main branch: %v", err)
	}

	// Create provider on main branch
	provider, err := NewLocalProvider(tempDir, "master")
	if err != nil {
		t.Fatalf("failed to create provider: %v", err)
	}

	// Get tree for feature branch (not current branch)
	tree, err := provider.Tree("feature")
	if err != nil {
		t.Fatalf("failed to get tree for feature branch: %v", err)
	}

	// Verify feature branch has both main.txt and feature.txt
	found := make(map[string]bool)
	for _, child := range tree.Children {
		found[child.Name] = true
	}

	if !found["main.txt"] {
		t.Error("expected main.txt to be in feature branch tree")
	}

	if !found["feature.txt"] {
		t.Error("expected feature.txt to be in feature branch tree")
	}

	// Get tree for main branch (current branch)
	tree, err = provider.Tree("master")
	if err != nil {
		t.Fatalf("failed to get tree for main branch: %v", err)
	}

	// Verify main branch has only main.txt
	found = make(map[string]bool)
	for _, child := range tree.Children {
		found[child.Name] = true
	}

	if !found["main.txt"] {
		t.Error("expected main.txt to be in main branch tree")
	}

	if found["feature.txt"] {
		t.Error("expected feature.txt NOT to be in main branch tree")
	}
}

// TestFileContent_NonHEADBranch tests that reading file from non-HEAD branch returns committed content.
func TestFileContent_NonHEADBranch(t *testing.T) {
	// Create a temporary git repository
	tempDir := t.TempDir()
	repo, err := git.PlainInit(tempDir, false)
	if err != nil {
		t.Fatalf("failed to init test repo: %v", err)
	}

	w, err := repo.Worktree()
	if err != nil {
		t.Fatalf("failed to get worktree: %v", err)
	}

	// Create file on main branch with initial content
	testFile := filepath.Join(tempDir, "test.md")
	if err := os.WriteFile(testFile, []byte("main content"), 0644); err != nil {
		t.Fatalf("failed to write test file: %v", err)
	}

	if _, err := w.Add("test.md"); err != nil {
		t.Fatalf("failed to add file: %v", err)
	}

	if _, err := w.Commit("initial commit", &git.CommitOptions{}); err != nil {
		t.Fatalf("failed to commit: %v", err)
	}

	// Create feature branch
	headRef, err := repo.Head()
	if err != nil {
		t.Fatalf("failed to get HEAD: %v", err)
	}

	featureBranchRef := plumbing.NewBranchReferenceName("feature")
	err = repo.Storer.SetReference(plumbing.NewHashReference(featureBranchRef, headRef.Hash()))
	if err != nil {
		t.Fatalf("failed to create feature branch: %v", err)
	}

	// Checkout feature branch
	if err := w.Checkout(&git.CheckoutOptions{Branch: featureBranchRef}); err != nil {
		t.Fatalf("failed to checkout feature branch: %v", err)
	}

	// Modify file on feature branch and commit
	if err := os.WriteFile(testFile, []byte("feature content"), 0644); err != nil {
		t.Fatalf("failed to write modified file: %v", err)
	}

	if _, err := w.Add("test.md"); err != nil {
		t.Fatalf("failed to add modified file: %v", err)
	}

	if _, err := w.Commit("modify on feature", &git.CommitOptions{}); err != nil {
		t.Fatalf("failed to commit modified file: %v", err)
	}

	// Checkout main branch
	mainBranchRef := plumbing.NewBranchReferenceName("master")
	if err := w.Checkout(&git.CheckoutOptions{Branch: mainBranchRef}); err != nil {
		t.Fatalf("failed to checkout main branch: %v", err)
	}

	// Create provider on main branch
	provider, err := NewLocalProvider(tempDir, "master")
	if err != nil {
		t.Fatalf("failed to create provider: %v", err)
	}

	// Read file from main branch (current branch - should read from working tree)
	content, err := provider.FileContent("test.md", "master")
	if err != nil {
		t.Fatalf("failed to read file from main branch: %v", err)
	}

	if string(content) != "main content" {
		t.Errorf("expected 'main content' from main branch, got: %s", string(content))
	}

	// Read file from feature branch (non-HEAD branch - should read from git object store)
	content, err = provider.FileContent("test.md", "feature")
	if err != nil {
		t.Fatalf("failed to read file from feature branch: %v", err)
	}

	if string(content) != "feature content" {
		t.Errorf("expected 'feature content' from feature branch, got: %s", string(content))
	}
}

// TestFileContent_HEADBranchWithUncommittedChanges tests that current branch reads include uncommitted changes.
func TestFileContent_HEADBranchWithUncommittedChanges(t *testing.T) {
	// Create a temporary git repository
	tempDir := t.TempDir()
	repo, err := git.PlainInit(tempDir, false)
	if err != nil {
		t.Fatalf("failed to init test repo: %v", err)
	}

	w, err := repo.Worktree()
	if err != nil {
		t.Fatalf("failed to get worktree: %v", err)
	}

	// Create and commit file
	testFile := filepath.Join(tempDir, "test.md")
	if err := os.WriteFile(testFile, []byte("committed content"), 0644); err != nil {
		t.Fatalf("failed to write test file: %v", err)
	}

	if _, err := w.Add("test.md"); err != nil {
		t.Fatalf("failed to add file: %v", err)
	}

	if _, err := w.Commit("initial commit", &git.CommitOptions{}); err != nil {
		t.Fatalf("failed to commit: %v", err)
	}

	// Modify file without committing (uncommitted change)
	if err := os.WriteFile(testFile, []byte("uncommitted content"), 0644); err != nil {
		t.Fatalf("failed to modify file: %v", err)
	}

	// Create provider
	provider, err := NewLocalProvider(tempDir, "")
	if err != nil {
		t.Fatalf("failed to create provider: %v", err)
	}

	// Read file from current branch (should include uncommitted changes)
	content, err := provider.FileContent("test.md", "")
	if err != nil {
		t.Fatalf("failed to read file: %v", err)
	}

	if string(content) != "uncommitted content" {
		t.Errorf("expected 'uncommitted content' (working tree), got: %s", string(content))
	}
}

// TestWriteFile_CreateNewFile tests writing a new file to the repository.
func TestWriteFile_CreateNewFile(t *testing.T) {
	// Create a temporary git repository
	tempDir := t.TempDir()
	_, err := git.PlainInit(tempDir, false)
	if err != nil {
		t.Fatalf("failed to init test repo: %v", err)
	}

	// Create provider
	provider, err := NewLocalProvider(tempDir, "")
	if err != nil {
		t.Fatalf("failed to create provider: %v", err)
	}

	// Write a new file
	content := []byte("# Test File\n\nThis is a test.")
	err = provider.WriteFile("test.md", content)
	if err != nil {
		t.Fatalf("failed to write file: %v", err)
	}

	// Verify file exists and has correct content
	fullPath := filepath.Join(tempDir, "test.md")
	readContent, err := os.ReadFile(fullPath)
	if err != nil {
		t.Fatalf("failed to read written file: %v", err)
	}

	if string(readContent) != string(content) {
		t.Errorf("expected content %q, got %q", string(content), string(readContent))
	}
}

// TestWriteFile_CreateNestedFile tests writing a file in nested directories.
func TestWriteFile_CreateNestedFile(t *testing.T) {
	// Create a temporary git repository
	tempDir := t.TempDir()
	_, err := git.PlainInit(tempDir, false)
	if err != nil {
		t.Fatalf("failed to init test repo: %v", err)
	}

	// Create provider
	provider, err := NewLocalProvider(tempDir, "")
	if err != nil {
		t.Fatalf("failed to create provider: %v", err)
	}

	// Write a file in nested directories
	content := []byte("nested file content")
	err = provider.WriteFile("docs/guides/setup.md", content)
	if err != nil {
		t.Fatalf("failed to write nested file: %v", err)
	}

	// Verify file exists and has correct content
	fullPath := filepath.Join(tempDir, "docs", "guides", "setup.md")
	readContent, err := os.ReadFile(fullPath)
	if err != nil {
		t.Fatalf("failed to read written file: %v", err)
	}

	if string(readContent) != string(content) {
		t.Errorf("expected content %q, got %q", string(content), string(readContent))
	}
}

// TestWriteFile_PathTraversalBlocked tests that path traversal attacks are blocked.
func TestWriteFile_PathTraversalBlocked(t *testing.T) {
	// Create a temporary git repository
	tempDir := t.TempDir()
	_, err := git.PlainInit(tempDir, false)
	if err != nil {
		t.Fatalf("failed to init test repo: %v", err)
	}

	// Create provider
	provider, err := NewLocalProvider(tempDir, "")
	if err != nil {
		t.Fatalf("failed to create provider: %v", err)
	}

	// Attempt path traversal
	err = provider.WriteFile("../../../etc/passwd", []byte("malicious"))
	if err == nil {
		t.Fatal("expected error for path traversal, got nil")
	}

	if !strings.Contains(err.Error(), "cannot contain '..'") {
		t.Errorf("expected error about '..' in path, got: %v", err)
	}
}

// TestDeleteFile_RemoveFile tests deleting an existing file.
func TestDeleteFile_RemoveFile(t *testing.T) {
	// Create a temporary git repository
	tempDir := t.TempDir()
	_, err := git.PlainInit(tempDir, false)
	if err != nil {
		t.Fatalf("failed to init test repo: %v", err)
	}

	// Create a test file
	testFile := filepath.Join(tempDir, "test.md")
	if err := os.WriteFile(testFile, []byte("test content"), 0644); err != nil {
		t.Fatalf("failed to write test file: %v", err)
	}

	// Create provider
	provider, err := NewLocalProvider(tempDir, "")
	if err != nil {
		t.Fatalf("failed to create provider: %v", err)
	}

	// Delete the file
	err = provider.DeleteFile("test.md")
	if err != nil {
		t.Fatalf("failed to delete file: %v", err)
	}

	// Verify file no longer exists
	if _, err := os.Stat(testFile); !os.IsNotExist(err) {
		t.Error("expected file to be deleted, but it still exists")
	}
}

// TestDeleteFile_NonexistentFile tests deleting a nonexistent file returns error.
func TestDeleteFile_NonexistentFile(t *testing.T) {
	// Create a temporary git repository
	tempDir := t.TempDir()
	_, err := git.PlainInit(tempDir, false)
	if err != nil {
		t.Fatalf("failed to init test repo: %v", err)
	}

	// Create provider
	provider, err := NewLocalProvider(tempDir, "")
	if err != nil {
		t.Fatalf("failed to create provider: %v", err)
	}

	// Attempt to delete nonexistent file
	err = provider.DeleteFile("nonexistent.md")
	if err == nil {
		t.Fatal("expected error for nonexistent file, got nil")
	}

	if !strings.Contains(err.Error(), "file not found") {
		t.Errorf("expected 'file not found' error, got: %v", err)
	}
}

// TestMoveFile_RenameFile tests moving/renaming a file.
func TestMoveFile_RenameFile(t *testing.T) {
	// Create a temporary git repository
	tempDir := t.TempDir()
	_, err := git.PlainInit(tempDir, false)
	if err != nil {
		t.Fatalf("failed to init test repo: %v", err)
	}

	// Create a test file
	oldFile := filepath.Join(tempDir, "old.md")
	content := []byte("file content")
	if err := os.WriteFile(oldFile, content, 0644); err != nil {
		t.Fatalf("failed to write test file: %v", err)
	}

	// Create provider
	provider, err := NewLocalProvider(tempDir, "")
	if err != nil {
		t.Fatalf("failed to create provider: %v", err)
	}

	// Move the file
	err = provider.MoveFile("old.md", "new.md")
	if err != nil {
		t.Fatalf("failed to move file: %v", err)
	}

	// Verify old file no longer exists
	if _, err := os.Stat(oldFile); !os.IsNotExist(err) {
		t.Error("expected old file to be deleted, but it still exists")
	}

	// Verify new file exists with same content
	newFile := filepath.Join(tempDir, "new.md")
	readContent, err := os.ReadFile(newFile)
	if err != nil {
		t.Fatalf("failed to read new file: %v", err)
	}

	if string(readContent) != string(content) {
		t.Errorf("expected content %q, got %q", string(content), string(readContent))
	}
}

// TestMoveFile_MoveToNestedPath tests moving a file to a nested directory.
func TestMoveFile_MoveToNestedPath(t *testing.T) {
	// Create a temporary git repository
	tempDir := t.TempDir()
	_, err := git.PlainInit(tempDir, false)
	if err != nil {
		t.Fatalf("failed to init test repo: %v", err)
	}

	// Create a test file
	oldFile := filepath.Join(tempDir, "file.md")
	content := []byte("file content")
	if err := os.WriteFile(oldFile, content, 0644); err != nil {
		t.Fatalf("failed to write test file: %v", err)
	}

	// Create provider
	provider, err := NewLocalProvider(tempDir, "")
	if err != nil {
		t.Fatalf("failed to create provider: %v", err)
	}

	// Move the file to nested directory
	err = provider.MoveFile("file.md", "docs/guides/file.md")
	if err != nil {
		t.Fatalf("failed to move file: %v", err)
	}

	// Verify old file no longer exists
	if _, err := os.Stat(oldFile); !os.IsNotExist(err) {
		t.Error("expected old file to be deleted, but it still exists")
	}

	// Verify new file exists with same content
	newFile := filepath.Join(tempDir, "docs", "guides", "file.md")
	readContent, err := os.ReadFile(newFile)
	if err != nil {
		t.Fatalf("failed to read new file: %v", err)
	}

	if string(readContent) != string(content) {
		t.Errorf("expected content %q, got %q", string(content), string(readContent))
	}
}

// TestCommit_CreateCommit tests creating a git commit.
func TestCommit_CreateCommit(t *testing.T) {
	// Create a temporary git repository
	tempDir := t.TempDir()
	repo, err := git.PlainInit(tempDir, false)
	if err != nil {
		t.Fatalf("failed to init test repo: %v", err)
	}

	// Create provider
	provider, err := NewLocalProvider(tempDir, "")
	if err != nil {
		t.Fatalf("failed to create provider: %v", err)
	}

	// Write a new file
	err = provider.WriteFile("test.md", []byte("test content"))
	if err != nil {
		t.Fatalf("failed to write file: %v", err)
	}

	// Create commit
	message := "Add test.md file"
	hash, err := provider.Commit(message)
	if err != nil {
		t.Fatalf("failed to create commit: %v", err)
	}

	// Verify hash is not empty
	if hash == "" {
		t.Error("expected non-empty commit hash, got empty string")
	}

	// Verify commit exists in repository
	commitObj, err := repo.CommitObject(plumbing.NewHash(hash))
	if err != nil {
		t.Fatalf("failed to get commit object: %v", err)
	}

	// Verify commit message
	if commitObj.Message != message {
		t.Errorf("expected commit message %q, got %q", message, commitObj.Message)
	}

	// Verify repository is clean after commit
	status, err := provider.Status()
	if err != nil {
		t.Fatalf("failed to get status: %v", err)
	}

	if status.IsDirty {
		t.Error("expected clean repository after commit, got dirty")
	}
}

// TestCommit_EmptyMessage tests that empty commit messages are rejected.
func TestCommit_EmptyMessage(t *testing.T) {
	// Create a temporary git repository
	tempDir := t.TempDir()
	_, err := git.PlainInit(tempDir, false)
	if err != nil {
		t.Fatalf("failed to init test repo: %v", err)
	}

	// Create provider
	provider, err := NewLocalProvider(tempDir, "")
	if err != nil {
		t.Fatalf("failed to create provider: %v", err)
	}

	// Attempt to commit with empty message
	_, err = provider.Commit("")
	if err == nil {
		t.Fatal("expected error for empty commit message, got nil")
	}

	if !strings.Contains(err.Error(), "cannot be empty") {
		t.Errorf("expected error about empty message, got: %v", err)
	}
}
